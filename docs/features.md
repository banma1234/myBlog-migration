# 🚀 Features

## SSG & SSR

정적 배포인 `SSG`와 서버사이드 랜더링 `SSR`을 적재적소에 활용하여 최대한 사용자 경험을 향상하고자 노력했습니다.

기본적으로 SSG를 고수하되 관리자 페이지에서의 데이터 요청과 같이 신선한 데이터가 필요한 상황에서는 컴포넌트 단위로 SSR을 적용하였습니다. SSR이 적용된 컴포넌트는 다음과 같습니다.

- 빌드 이후에 작성된 포스트
- 관리자 페이지의 데이터 fetching
- 메인페이지와 검색페이지의 데이터 fetching
- sitemap.xml

기본적으로 포스트는 SSG로 export하지만 SSG의 특성상 빌드 이후에 작성된 포스트를 export할 수 없으므로 빌드 이후에 작성된 포스트는 SSR로 페이지를 생성하도록 하였습니다. 같은 이유로 메인페이지의 데이터 fetching에 `revalidate`를 주어 기존의 데이터와 차이가 있을 경우 신선한 데이터를 불러오도록 하였습니다. 관리자 페이지의 데이터는 항상 신선산 데이터를 받아오도록 하였습니다.

상황에 따라 `CSR`을 사용하기도 하였습니다. 댓글의 경우 페이지의 하단에 위치하기 때문에 CSR 특유의 렌더링시 딜레이가 의미 없다고 판단, input에 포커스를 두거나 새로고침 없이 댓글을 작성/삭제를 수행하는 등 client-side에서 동작하는 `React`의 기능을 활용하여 사용자 경험을 향상하였습니다.

<br/>

## SEO

검색엔진에서의 노출을 최대화 하기 위해 다음과 같은 파일을 서치콘솔에 제출하였습니다.

- manifest.json
- robots.txt
- sitemap.xml
- RSS_feed.xml

`manifest`와 `robots`는 정적파일로, `sitemap`은 `SSR`을 적용해 매 요청마다 신선한 데이터를 제공할 수 있도록 하였습니다. 이는 빌드 이후에 작성된 포스트 또한 sitemap에 추가시키기 위한 조치였습니다.

`RSS feed`의 경우 `feed` 라이브러리를 이용해 런타임 빌드시 정적 파일을 생성하도록 구현하였습니다.

<br/>

포스트를 정적으로 생성하기 때문에 각 포스트에 해당되는 meta태그 또한 런타임 빌드시 정적으로 생성하도록 구현하였습니다. meta데이터를 DB로부터 전달받아 각 포스트에 매핑합니다.

<br/>

## authentication & middleware

`next-auth` 라이브러리를 이용해 세션 로그인을 구현하였습니다. 로그인 서비스 사용자가 관리자 1명 뿐이기 때문에 stateless한 jwt 토큰이 불필요하다 판단했습니다.

이메일과 비밀번호를 입력하여 로그인을 진행하며 암호화되어 DB에 저장된 비밀번호와 입력 비밀번호를 비교하여 로그인을 수행합니다. 암호화 알고리즘으로는 `bcrypt`를 채택하였습니다.

`middleware`를 두어 비로그인 유저의 admin/\*\* 라우트에 대한 접근을 차단하였습니다. 마찬가지로 댓글을 제외한 모든 `POST`, `PUT`, `DELETE` api에 대한 접근을 차단하였습니다.

`context provider`를 두어 클라이언트에서 세션 정보를 조회하고 로그인 상태를 유지할 수 있도록 하였습니다.

<br/>

## markdown to html (with styling)

`marked` 라이브러리를 이용해 마크다운 파일의 인코딩 및 디코딩 기능을 구현하였습니다. 마크다운 파일을 안전한 html 소스로 인코딩한 후 해당 내용을 DOM 트리에 직접 삽입합니다.

마크다운 스타일은 기본적으로 `github` 스타일을 따르되 codeblock, header 등 특정 태그(혹은 컴포넌트)의 경우 직접 스타일링한 컴포넌트를 사용하도록 하였습니다. 코드 스타일링은 `prismjs` 라이브러리를 사용하였습니다.

이미지 출력의 경우 별도의 CDN 서버를 도입하여 구현하였습니다. 자세한 내용은 [해당 링크](https://chocoham.dev/posts/28)를 참고해주시면 감사하겠습니다.

<br/>

## search posts

서버 컴포넌트에서 전체 데이터를 불러와 클라이언트 컴포넌트에서 검색 및 필터링, 페이지네이션을 수행할 수 있도록 구성하였습니다.

포스트의 개수가 많지 않기 때문에(작성날짜 기준 포스트는 총 29개 입니다) 무한 스크롤 방식과 같이 화면 단위로 혹은 페이지네이션 페이지 단위로 데이터를 끊어서 불러오지 않고 모든 데이터를 불러오도록 하였습니다. 데이터를 불러오는데 많은 자원이 소모되지 않기 때문입니다.

검색 로직 구현에는 React의 기능을 다수 활용하였습니다. `useState`, `useEffect` 등 React의 hooks를 활용하여 클라이언트에서의 끊김없는 검색 기능을 구현하였습니다.

하지만 포스트의 개수가 늘어나고 response 응답 시간이 늦어진다면 현재의 방식이 아닌 무한 스크롤 방식을 도입할 예정입니다.

<br/>

## comment-reply logic

`트리`구조를 활용해 댓글-대댓글 로직을 구현하였습니다. 자세한 내용은 [해당 링크](https://chocoham.dev/posts/31)를 참고해주시면 감사하겠습니다.
